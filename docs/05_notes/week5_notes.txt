MEMORIA WEEK 5 PROGRESS NOTES

These notes document the MEMORIA project's weekly progress for Week 5. This week completes User Input, Analysis & APIs for assignment compliance.

================================================================================

Section 1 Add-on: get_absolute_url() Usefulness
================================================

For which feature `get_absolute_url()` is implemented and useful:

  1. Conversation detail navigation
     - Implemented on the `Session` model.
     - Used in the sidebar conversation list so each session links to its own detail page.

  2. Memory detail navigation
     - Implemented on the `Memory` model.
     - Used in memory list cards so each item links to `/chat/m/<id>/` via model-driven URL resolution.

Why this is useful:

  - Single source of truth for object URLs.
  - Templates avoid hard-coded paths.
  - URL pattern changes only need model-level updates, improving maintainability.

================================================================================

Section 3 Add-on: Static Files & Cache Busting
===============================================

Static file organization choice:

We use a hybrid static structure:

  1. Project-level shared assets in `static/`
     - `static/css/` for global styles
     - `static/js/` for shared scripts
     - `static/images/` for shared icons and branding assets

  2. App-level feature assets in `app/<app_name>/static/<app_name>/`
     - `app/chat/static/chat/`
     - `app/users/static/users/`
     - `app/memoria/static/memoria/`

Why this choice is useful:

  - Shared resources are centralized and reusable.
  - Feature-specific styling stays close to each app.
  - It improves maintainability and reduces naming conflicts.

Cache busting explanation (implemented):

We append a version query parameter to static assets in templates, for example:

  `{% static 'css/base.css' %}?v={% now 'U' %}`

`{% now 'U' %}` generates the current Unix timestamp, which forces the browser to request a fresh file when CSS/JS changes during development.

Production note:

For production deployment, content-hash-based static files (for example with ManifestStaticFilesStorage) are preferred for stable and efficient long-term caching.

================================================================================

Section 6: Creating APIs (Completed Item)
=========================================

6.1 API Planning
-----------------

How we are planning to create an API for this project:

The project API is implemented under the `/chat/api/` route group in Django.  
We use `JsonResponse` as the primary response format for data endpoints, and we keep both FBV and CBV patterns to demonstrate multiple Django API styles required by the assignment.

Implementation approach:

  1. Route API URLs in `app/chat/urls.py` using clear resource-based paths.
  2. Implement API logic in `app/chat/api.py`.
  3. Reuse query and aggregation logic from the service layer (`app/chat/service.py`) so API responses remain consistent with UI pages.
  4. Use query parameters for non-destructive filtering.
  5. Require authentication on user-private resources.

6.2 Data to Serve
------------------

What kind of data we are planning to serve:

  1. Memory bullet data
     - id, content, memory_type, topic, strength
     - helpful_count, harmful_count
     - created_at, last_accessed

  2. Session data
     - session id and title
     - created_at, updated_at
     - detail URL for direct navigation

  3. Message data
     - per-session message list
     - role (user/assistant), content, timestamp

  4. Analytics summary data
     - total memories, total sessions, total messages
     - grouped memory-type counts
     - average strength and feedback totals

6.3 Filtering and Response Types
---------------------------------

Current filtering plan uses query parameters such as:

  - `q` for keyword matching
  - `type` for memory type
  - `topic` for memory topic
  - `strength_min` for minimum memory strength
  - `role` for message role filtering

Response-type plan:

  - Use `JsonResponse` for normal API payloads.
  - Keep one demo endpoint that can return HTML or plain text via `HttpResponse` to demonstrate MIME-type differences (`application/json` vs `text/html` vs `text/plain`).

================================================================================

Section 7: Testing Infrastructure
==================================

7.1 Test Architecture
----------------------

The testing infrastructure uses a standalone script-based approach (no pytest or
unittest framework) with argparse for selective test execution, print-based
assertions, and failure counters with sys.exit codes for CI compatibility.

Test files:

  1. `unit_test/mock_data.py`
     Shared test data module providing 8 user personas, 5 plans, 7 memories,
     26 memory bullets, 12 sessions, 36 messages, 5 subscriptions, and 7 payments.
     Also seeds the existing admin account ('tester') with 5 sessions, 13 messages,
     1 memory, and 5 memory bullets so the admin sees demo content immediately.
     All sessions are backdated to different days within the last 30 days to
     produce a realistic Conversation Activity chart (with at least one day
     containing 2 sessions).
     Exports `cleanup_all_test_data()` and `create_all_test_data()` functions
     used by both test files.

  2. `unit_test/database_unit_test.py`
     Tests database relationships and constraints: FK chains (Memory to
     MemoryBullet, Session to Message, Subscription to Payment), uniqueness
     constraints (Plan code+interval, Subscription user+plan), on_delete
     behaviors (CASCADE, PROTECT, SET_NULL), and model methods
     (create_with_opening_exchange, get_absolute_url, __str__).

  3. `unit_test/feature_unit_test.py`
     Tests all 20 service layer functions from app/chat/service.py, 5 user
     service functions from app/users/services.py, 4 API payload builders, 3
     chart generators (PNG validation), and edge cases (empty users, boundary
     values, non-numeric filter parameters). Contains 67 tests organized into
     8 independently runnable groups (--test-users, --test-sessions,
     --test-memory, --test-analytics, --test-charts, --test-api,
     --test-models, --test-edge).

7.2 Coverage Summary
---------------------

  Database tests:
    - FK relationship validation across all model chains
    - Uniqueness constraints for Plan and Subscription
    - on_delete behaviors: CASCADE (auth.User through full chain),
      PROTECT (Plan with Subscriptions), SET_NULL (Payment.subscription,
      Payment.plan)
    - Model methods: create_with_opening_exchange, get_absolute_url, __str__

  Service layer tests:
    - User services: validate_registration (5 cases), create_user_with_profile,
      get_or_create_profile_for_user (idempotency)
    - Session services: sidebar sessions, home context, create/get/message
      operations, Http404 for invalid and cross-user access
    - Memory services: list data with filtering and sorting, summary aggregates
    - Analytics: dashboard context with type_summary labels
    - Charts: all 3 chart functions return valid PNG bytes
    - API payloads: all 4 payload builders with filter combinations

  Edge case tests:
    - Empty user returns zero/empty for all service functions
    - Non-numeric filter parameters gracefully ignored
    - Whitespace and empty string inputs handled correctly

7.3 Mock Data Design
---------------------

The 8 user personas serve specific testing purposes:

  - maria_garcia: Power user with 7 memory bullets, 4 sessions, pro subscriber
  - james_chen: Free tier with 5 bullets, 3 sessions, moderate activity
  - sarah_johnson: Episodic memory focus, 5 bullets, expired subscription
  - alex_kumar: New user with minimal data (2 bullets, 0 sessions)
  - emma_wilson: CASCADE deletion target with full data chain
  - test_edge_empty: Zero data, tests empty queryset code paths
  - test_edge_maxlen: Maximum length fields for boundary testing
  - test_edge_special: Special characters in content and metadata

  Admin seeding (Step 8):
  The script detects the existing admin account ('tester') and seeds it with
  demo sessions, messages, and memories so the admin user sees data in the
  sidebar, memory page, and analytics charts without creating a separate
  test account. The admin's chat data is cleaned on each re-run (the account
  itself is preserved). Sessions are backdated to days 28, 21, 12, and 6
  (two sessions share day 6 to demonstrate multi-session days on the chart).

Memory bullet strengths cover all 5 histogram buckets:
  0-20: 17 bullets | 21-40: 2 | 41-60: 3 | 61-80: 1 | 81-100: 2

Subscription statuses: ACTIVE (3), EXPIRED (1), INCOMPLETE (1)
Payment statuses: SUCCEEDED (3), FAILED (1), PENDING (1), CANCELLED (1)
