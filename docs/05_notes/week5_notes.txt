MEMORIA WEEK 5 PROGRESS NOTES

These notes document the MEMORIA project's weekly progress for Week 5. This week completes User Input, Analysis & APIs for assignment compliance.

================================================================================

Section 1 Add-on: get_absolute_url() Usefulness
================================================

For which feature `get_absolute_url()` is implemented and useful:

  1. Conversation detail navigation
     - Implemented on the `Session` model.
     - Used in the sidebar conversation list so each session links to its own detail page.

  2. Memory detail navigation
     - Implemented on the `Memory` model.
     - Used in memory list cards so each item links to `/chat/m/<id>/` via model-driven URL resolution.

Why this is useful:

  - Single source of truth for object URLs.
  - Templates avoid hard-coded paths.
  - URL pattern changes only need model-level updates, improving maintainability.

================================================================================

Section 3 Add-on: Static Files & Cache Busting
===============================================

Static file organization choice:

We use a hybrid static structure:

  1. Project-level shared assets in `static/`
     - `static/css/` for global styles
     - `static/js/` for shared scripts
     - `static/images/` for shared icons and branding assets

  2. App-level feature assets in `app/<app_name>/static/<app_name>/`
     - `app/chat/static/chat/`
     - `app/users/static/users/`
     - `app/memoria/static/memoria/`

Why this choice is useful:

  - Shared resources are centralized and reusable.
  - Feature-specific styling stays close to each app.
  - It improves maintainability and reduces naming conflicts.

Cache busting explanation (implemented):

We append a version query parameter to static assets in templates, for example:

  `{% static 'css/base.css' %}?v={% now 'U' %}`

`{% now 'U' %}` generates the current Unix timestamp, which forces the browser to request a fresh file when CSS/JS changes during development.

Production note:

For production deployment, content-hash-based static files (for example with ManifestStaticFilesStorage) are preferred for stable and efficient long-term caching.

================================================================================

Section 6: Creating APIs (Completed Item)
=========================================

6.1 API Planning
-----------------

How we are planning to create an API for this project:

The project API is implemented under the `/chat/api/` route group in Django.  
We use `JsonResponse` as the primary response format for data endpoints, and we keep both FBV and CBV patterns to demonstrate multiple Django API styles required by the assignment.

Implementation approach:

  1. Route API URLs in `app/chat/urls.py` using clear resource-based paths.
  2. Implement API logic in `app/chat/api.py`.
  3. Reuse query and aggregation logic from the service layer (`app/chat/service.py`) so API responses remain consistent with UI pages.
  4. Use query parameters for non-destructive filtering.
  5. Require authentication on user-private resources.

6.2 Data to Serve
------------------

What kind of data we are planning to serve:

  1. Memory bullet data
     - id, content, memory_type, topic, strength
     - helpful_count, harmful_count
     - created_at, last_accessed

  2. Session data
     - session id and title
     - created_at, updated_at
     - detail URL for direct navigation

  3. Message data
     - per-session message list
     - role (user/assistant), content, timestamp

  4. Analytics summary data
     - total memories, total sessions, total messages
     - grouped memory-type counts
     - average strength and feedback totals

6.3 Filtering and Response Types
---------------------------------

Current filtering plan uses query parameters such as:

  - `q` for keyword matching
  - `type` for memory type
  - `topic` for memory topic
  - `strength_min` for minimum memory strength
  - `role` for message role filtering

Response-type plan:

  - Use `JsonResponse` for normal API payloads.
  - Keep one demo endpoint that can return HTML or plain text via `HttpResponse` to demonstrate MIME-type differences (`application/json` vs `text/html` vs `text/plain`).

================================================================================

Section 7: Testing Infrastructure
==================================

7.1 Test Architecture
----------------------

The testing infrastructure uses a standalone script-based approach (no pytest or
unittest framework) with argparse for selective test execution, print-based
assertions, and failure counters with sys.exit codes for CI compatibility.

Test files:

  1. `unit_test/mock_data.py`
     Shared test data module providing 8 user personas, 5 plans, 7 memories,
     26 memory bullets, 12 sessions, 36 messages, 5 subscriptions, and 7 payments.
     Also seeds the existing admin account ('tester') with 5 sessions, 13 messages,
     1 memory, and 5 memory bullets so the admin sees demo content immediately.
     All sessions are backdated to different days within the last 30 days to
     produce a realistic Conversation Activity chart (with at least one day
     containing 2 sessions).
     Exports `cleanup_all_test_data()` and `create_all_test_data()` functions
     used by both test files.

  2. `unit_test/database_unit_test.py`
     Tests database relationships and constraints: FK chains (Memory to
     MemoryBullet, Session to Message, Subscription to Payment), uniqueness
     constraints (Plan code+interval, Subscription user+plan), on_delete
     behaviors (CASCADE, PROTECT, SET_NULL), and model methods
     (create_with_opening_exchange, get_absolute_url, __str__).

  3. `unit_test/feature_unit_test.py`
     Tests all 20 service layer functions from app/chat/service.py, 5 user
     service functions from app/users/services.py, 4 API payload builders, 3
     chart generators (PNG validation), and edge cases (empty users, boundary
     values, non-numeric filter parameters). Contains 67 tests organized into
     8 independently runnable groups (--test-users, --test-sessions,
     --test-memory, --test-analytics, --test-charts, --test-api,
     --test-models, --test-edge).

7.2 Coverage Summary
---------------------

  Database tests:
    - FK relationship validation across all model chains
    - Uniqueness constraints for Plan and Subscription
    - on_delete behaviors: CASCADE (auth.User through full chain),
      PROTECT (Plan with Subscriptions), SET_NULL (Payment.subscription,
      Payment.plan)
    - Model methods: create_with_opening_exchange, get_absolute_url, __str__

  Service layer tests:
    - User services: validate_registration (5 cases), create_user_with_profile,
      get_or_create_profile_for_user (idempotency)
    - Session services: sidebar sessions, home context, create/get/message
      operations, Http404 for invalid and cross-user access
    - Memory services: list data with filtering and sorting, summary aggregates
    - Analytics: dashboard context with type_summary labels
    - Charts: all 3 chart functions return valid PNG bytes
    - API payloads: all 4 payload builders with filter combinations

  Edge case tests:
    - Empty user returns zero/empty for all service functions
    - Non-numeric filter parameters gracefully ignored
    - Whitespace and empty string inputs handled correctly

7.3 Mock Data Design
---------------------

The 8 user personas serve specific testing purposes:

  - maria_garcia: Power user with 7 memory bullets, 4 sessions, pro subscriber
  - james_chen: Free tier with 5 bullets, 3 sessions, moderate activity
  - sarah_johnson: Episodic memory focus, 5 bullets, expired subscription
  - alex_kumar: New user with minimal data (2 bullets, 0 sessions)
  - emma_wilson: CASCADE deletion target with full data chain
  - test_edge_empty: Zero data, tests empty queryset code paths
  - test_edge_maxlen: Maximum length fields for boundary testing
  - test_edge_special: Special characters in content and metadata

  Admin seeding (Step 8):
  The script detects the existing admin account ('tester') and seeds it with
  demo sessions, messages, and memories so the admin user sees data in the
  sidebar, memory page, and analytics charts without creating a separate
  test account. The admin's chat data is cleaned on each re-run (the account
  itself is preserved). Sessions are backdated to days 28, 21, 12, and 6
  (two sessions share day 6 to demonstrate multi-session days on the chart).

Memory bullet strengths cover all 5 histogram buckets:
  0-20: 17 bullets | 21-40: 2 | 41-60: 3 | 61-80: 1 | 81-100: 2

Subscription statuses: ACTIVE (3), EXPIRED (1), INCOMPLETE (1)
Payment statuses: SUCCEEDED (3), FAILED (1), PENDING (1), CANCELLED (1)

================================================================================

Section 8: Functional Unit Mappings (View to Model to URL to Template)
======================================================================

Each unit below documents one interconnected feature: the view function or
class in views.py, the model class(es) it queries from models.py, the URL
pattern in urls.py, and the template it renders (or JSON response for APIs).

8.1 Landing Page Unit
----------------------

  View:     app/memoria/views.py :: landing() [FBV]
  Model:    None (static page)
  URL:      app/memoria/urls.py :: path("", views.landing, name="landing")
  Template: app/memoria/templates/memoria/landing.html

  Flow: User visits / -> landing() renders the landing page. If the user is
  already authenticated, the page shows a link to /home/. Otherwise it shows
  Log in and Register buttons that open modal dialogs loaded via AJAX from
  the users app.

8.2 Home Page Unit
-------------------

  View:     app/memoria/views.py :: home() [FBV]
  Models:   chat.Session, chat.Memory (via service layer)
  URL:      app/memoria/urls.py :: path("home/", views.home, name="home")
  Template: app/memoria/templates/memoria/home.html

  Flow: GET renders the home dashboard. If the user is authenticated,
  get_home_context_for_user() provides the user's sessions (ordered by
  created_at descending) and memories (ordered by updated_at descending)
  for display. Unauthenticated users see a guest view with empty lists.
  POST reads request.POST["message"], creates a new Session with an
  opening exchange via create_home_session_for_user(), and redirects to
  session.get_absolute_url(). If the message is empty or session creation
  fails, the view redirects back to /home/.

  Form on this page:
    POST form: method="post" with {% csrf_token %}, name="message",
    creates a new conversation session and redirects to it.

8.3 Conversation Detail Unit
-----------------------------

  View:     app/chat/views.py :: ConversationMessagesView [CBV: View]
  Models:   chat.Session, chat.Message
  URL:      app/chat/urls.py :: path("c/<int:session_id>/", ..., name="conversation_detail")
  Template: app/chat/templates/chat/conversation_detail.html

  Flow: GET loads the session with prefetched messages via
  get_session_for_user(with_messages=True). POST reads request.POST["message"],
  creates a user message and an agent reply via
  create_user_message_with_agent_reply(), then redirects back to
  session.get_absolute_url(). AJAX POST returns a JsonResponse instead.
  The template uses {% for %} to iterate messages and {% csrf_token %} for
  the POST form.

8.4 Memory List Unit
---------------------

  View:     app/chat/views.py :: MemoryListView [CBV: ListView]
  Models:   chat.MemoryBullet, chat.Memory
  URL:      app/chat/urls.py :: path("memory/", ..., name="memory")
  Template: app/chat/templates/chat/memory.html

  Flow: The ListView handles both GET and POST. post() delegates to get().
  get_queryset() reads search_query, memory_type, and sort_key from either
  request.POST or request.GET, then calls get_memory_list_data() which
  filters using __icontains and __gte lookups, annotates with
  ExpressionWrapper(F("helpful_count") - F("harmful_count")), and orders
  results. get_context_data() adds aggregation summaries from
  get_memory_summary() (Count, Avg, Max, Min, Sum). The template uses
  {% for %}/{% empty %} for the memory grid and links each card to
  bullet.memory.get_absolute_url.

  Search form: method="post" with {% csrf_token %}, name="q" for search,
  hidden inputs for type and sort filters.

8.5 Memory Detail Unit
-----------------------

  View:     app/chat/views.py :: MemoryBulletsView [CBV: DetailView]
  Models:   chat.Memory, chat.MemoryBullet
  URL:      app/chat/urls.py :: path("m/<int:memory_id>/", ..., name="memory_detail")
  Template: app/chat/templates/chat/memory_detail.html

  Flow: The DetailView uses pk_url_kwarg="memory_id" to look up a Memory
  record. get_queryset() filters by the current user's profile and
  prefetches the related memorybullet_set. The template displays breadcrumb
  navigation (back to /chat/memory/), memory metadata (access_clock,
  created_at, updated_at), and iterates over memorybullet_set.all showing
  each bullet's type, topic, content, strength, helpful/harmful counts,
  TTL, and last_accessed. Uses {% for %}/{% empty %} for the bullet list.

8.6 Analytics Dashboard Unit
------------------------------

  View:     app/chat/views.py :: analytics_view() [FBV]
            app/chat/views.py :: memory_type_chart_png() [FBV]
            app/chat/views.py :: memory_strength_chart_png() [FBV]
            app/chat/views.py :: activity_chart_png() [FBV]
  Models:   chat.MemoryBullet, chat.Session, chat.Message
  URLs:     app/chat/urls.py ::
              path("analytics/", ..., name="analytics")
              path("analytics/memory-type.png", ..., name="memory_type_chart")
              path("analytics/memory-strength.png", ..., name="memory_strength_chart")
              path("analytics/activity.png", ..., name="activity_chart")
  Template: app/chat/templates/chat/analytics.html (dashboard page)
            PNG image endpoints return HttpResponse(content_type="image/png")

  Flow: analytics_view() calls get_analytics_dashboard_context() which
  computes total_memories, total_sessions, total_messages, avg_strength,
  and type_summary using Count, Avg, Sum aggregations. The template displays
  stat cards and embeds three chart images via <img src="{% url ... %}">.
  Each chart view calls a service function that queries the ORM, generates
  a Matplotlib figure, renders it to a BytesIO buffer, calls plt.close()
  to prevent memory leaks, and returns the PNG bytes. Charts: pie (memory
  type distribution), bar (memory strength histogram), line (30-day
  session activity via TruncDate + Count).

8.7 User Authentication Unit
------------------------------

  View:     app/users/views.py :: login_view() [FBV]
            app/users/views.py :: register_view() [FBV]
            app/users/views.py :: logout_view() [FBV]
  Models:   django.contrib.auth.models.User, app.users.models.User (profile)
  URLs:     app/users/urls.py ::
              path("login/", ..., name="login")
              path("register/", ..., name="register")
              path("logout/", ..., name="logout")
  Templates: app/users/templates/users/login_form.html
             app/users/templates/users/register_form.html

  Flow: login_view() handles GET (returns form HTML for AJAX modal loading)
  and POST (authenticates via services.authenticate_and_login(), returns
  JsonResponse for AJAX or redirects). register_view() validates via
  services.validate_registration(), creates user+profile via
  services.create_user_with_profile(), and logs in. logout_view() calls
  django.contrib.auth.logout() and redirects. All POST forms include
  {% csrf_token %}.

8.8 Profile and Password Unit
-------------------------------

  View:     app/users/views.py :: profile_view() [FBV]
            app/users/views.py :: change_password_view() [FBV]
  Models:   app.users.models.User (profile with profile_img)
  URLs:     app/users/urls.py ::
              path("profile/", ..., name="profile")
              path("password-change/", ..., name="password_change")
  Templates: app/users/templates/users/profile.html
             app/users/templates/users/password_change_form.html

  Flow: profile_view() handles GET (renders profile page with username,
  email, avatar) and POST (updates profile_img via request.FILES, email via
  request.POST). change_password_view() validates current password, checks
  new password match, calls set_password() and update_session_auth_hash().
  Password form opens in a modal dialog via AJAX.

8.9 JSON API Unit
------------------

  View:     app/chat/api.py :: api_memory_bullets() [FBV]
            app/chat/api.py :: api_analytics_summary() [FBV]
            app/chat/api.py :: SessionAPIView [CBV: View]
            app/chat/api.py :: MessageAPIView [CBV: View]
            app/chat/api.py :: api_demo_response() [FBV]
  Models:   chat.MemoryBullet, chat.Memory, chat.Session, chat.Message
  URLs:     app/chat/urls.py ::
              path("api/memories/", ..., name="api_memories")
              path("api/analytics/", ..., name="api_analytics")
              path("api/sessions/", ..., name="api_sessions")
              path("api/sessions/<int:session_id>/messages/", ..., name="api_messages")
              path("api/demo/", ..., name="api_demo")
  Templates: None (all return JsonResponse or HttpResponse)

  Flow: Each API view calls a corresponding service function
  (get_api_memory_bullets_payload, get_api_analytics_summary_payload,
  get_api_sessions_payload, get_api_messages_payload) that queries the ORM,
  serializes results into dicts, and returns them. All user-scoped endpoints
  require login. Filtering via GET query parameters: ?q=, ?type=, ?topic=,
  ?strength_min=, ?role=. The demo endpoint returns JsonResponse for
  ?format=json, HttpResponse with text/html for ?format=html, and
  HttpResponse with text/plain for ?format=text, demonstrating MIME type
  differences.

  FBV APIs: api_memory_bullets (4 filters), api_analytics_summary (no filters)
  CBV APIs: SessionAPIView (?q= filter), MessageAPIView (?role= filter)

8.10 Session Management Unit
------------------------------

  View:     app/chat/views.py :: session_rename_view() [FBV]
            app/chat/views.py :: session_delete_view() [FBV]
  Models:   chat.Session
  URLs:     app/chat/urls.py ::
              path("c/<int:session_id>/rename/", ..., name="session_rename")
              path("c/<int:session_id>/delete/", ..., name="session_delete")
  Templates: None (return JsonResponse)

  Flow: Both are POST-only views (enforced by @require_http_methods(["POST"])).
  session_rename_view() reads request.POST["title"], truncates to 200
  characters, saves, and returns {"ok": true, "title": "..."}. 
  session_delete_view() deletes the session (CASCADE removes all messages)
  and returns {"ok": true}. Called from JavaScript in main.js via fetch()
  with CSRF token in the X-CSRFToken header.

================================================================================

Section 9: Teammate Notes, Reminders, and Challenges
====================================================

9.1 Reminders
--------------

  1. Always run "python manage.py migrate" after pulling changes.
  2. Copy .env.example to .env and set DJANGO_SECRET_KEY before running.
  3. Install all dependencies: pip install -r requirements.txt
     (includes matplotlib for chart generation).
  4. Seed demo data: python unit_test/mock_data.py
     This creates 8 test users and seeds the admin 'tester' account with
     sessions, messages, and memories for visible demo content.
  5. Run the dev server with:
     DJANGO_SETTINGS_MODULE=memoria.settings.development python manage.py runserver
  6. Run unit tests from the project root:
     python unit_test/database_unit_test.py
     python unit_test/feature_unit_test.py

9.2 Challenges Encountered
----------------------------

  1. Memory page form method: The memory search form was initially GET.
     We switched it to POST with {% csrf_token %} to demonstrate a POST
     search form that hides sensitive memory search terms from the URL.
     The backend get_queryset() reads from both request.POST and request.GET
     so the page still works if accessed with URL query parameters.

  2. Home page dual-purpose POST: The home page handles two distinct POST
     actions on the same URL. We distinguish them by checking which form
     field is present: request.POST.get("search") triggers conversation
     content search, while request.POST.get("message") creates a new
     session. This required careful ordering in the view logic.

  3. Chart memory management: Matplotlib figures must be explicitly closed
     with plt.close(fig) after rendering to BytesIO. Without this, repeated
     chart requests accumulate Figure objects and leak memory.

  4. CSRF for AJAX: Sidebar conversation rename and delete operations use
     JavaScript fetch() with POST. The CSRF token must be sent in the
     X-CSRFToken header, extracted from the csrftoken cookie, not as a form
     field.

9.3 Screenshot Evidence
------------------------

  All screenshot evidence is stored in docs/imgs/:

  Section 1 (URL Linking & Navigation):
    home_dashboard_normal.png       Home page with sidebar and content
    home_dashboard_empty.png        Home page with no session data
    sidebar_collapsed.png           Sidebar collapsed state
    sidebar_empty.png               Sidebar with no conversations
    conversation_detail_normal.png  Conversation detail page via PK link

  Section 2 (ORM Queries & Data Presentation):
    memory_management_normal.png    Memory list with stat cards and grid
    memory_management_empty.png     Empty memory list with {% empty %}
    memory_filtered_semantic.png    Filtered by Semantic memory type
    memory_searched.png             Search results for a query
    memory_searched_empty.png       Empty search results with {% empty %}
    memory_sorted_affect.png        Sorted by affect score
    memory_sorted_strength.png      Sorted by strength

  Section 3 (Static Files & UI Styling):
    landing_page.png                Landing page with custom fonts and layout
    profile_page_normal.png         Profile page with CSS styling
    profile_page_empty.png          Profile page with no avatar

  Section 5 (Forms & User Input):
    login_modal.png                 Login form with {% csrf_token %}
    login_error.png                 Login form with validation error
    register_modal.png              Register form with {% csrf_token %}
    register_error.png              Register form with validation error
    password_change_modal.png       Password change form

  Section 6 (Creating APIs):
    api_json_no_filter.png          JSON API response without filters
    api_json_with_filter.png        JSON API response with query filters
    api_http.png                    HttpResponse demo endpoint
